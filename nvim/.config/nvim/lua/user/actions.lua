local utils = require 'user.utils'
local pretty_print = utils.pretty_print
local find_in_project = function(opts)
  opts = opts or {
    literal_search = true,
    callback = function() end,
    noautocmd = false,
  }
  local bang = opts.literal_search and '' or '!'
  local noautocmd_str = opts.noautocmd and 'noautocmd ' or ''
  vim.ui.input({ prompt = 'Enter search term (blank for word under cursor): ' }, function(search_term)
    local original_search_term = search_term
    if search_term then
      search_term = ' ' .. search_term
    end

    vim.cmd(noautocmd_str .. 'RipGrepCWORD' .. bang .. search_term)
    opts.callback(original_search_term)
  end)
end

local search_and_replace = function(literal_search)
  find_in_project {
    literal_search = literal_search,
    callback = function(search_term)
      vim.ui.input({ prompt = 'Enter Replace term: ' }, function(replace_term)
        if not replace_term then
          pretty_print 'Canceled.'
          return
        end
        vim.ui.input({
          prompt = 'Enter flags (g=global, c=confirm, i=case insensitive, e=ignore errors, n=only count): ',
          default = 'gce',
        }, function(flags)
          if not flags then
            pretty_print 'Canceled.'
            return
          end
          vim.cmd('silent noautocmd cdo %s?' .. search_term .. '?' .. replace_term .. '?' .. flags)
        end)
      end)
    end,
    noautocmd = true,
  }
end

local T = vim.keycode

return {
  ['Find in pwd (literal search) (<C-f>)'] = function()
    find_in_project { literal_search = true }
  end,
  ['Find in pwd (regex search) (<C-f>)'] = function()
    find_in_project { literal_search = false }
  end,
  ['Search and Replace in pwd (literal search)'] = function()
    search_and_replace(true)
  end,
  ['Search and Replace in pwd (regex search)'] = function()
    search_and_replace(false)
  end,
  ['Replace word under cursor (<leader>r)'] = function()
    vim.fn.feedkeys(T '<leader>' .. 'r')
  end,
  ['Select all (vae / <leader>sa)'] = function()
    vim.cmd [[normal! ggVG]]
  end,
  ['Indent block forward (<leader>gt)'] = function()
    vim.cmd [[normal! v%koj$>]]
  end,
  ['[Folds] Open all folds (zR / <leader>fo)'] = function()
    vim.cmd 'normal! zR'
  end,
  ['[Folds] Open fold (za / <leader>ff)'] = function()
    vim.cmd 'normal! za'
  end,
  ['[Folds] Open all folds folds under the cursor (level fold) (<leader>fl)'] = function()
    vim.cmd 'normal! zazczA'
  end,
  ['[Folds] Close all folds (<leader>fc)'] = function()
    vim.cmd 'normal! zM'
  end,
  ['[Terraform] Add -target macro to register q'] = function()
    -- set q register to -target
    vim.fn.setreg('q', [[yss'I-target=A \j]])
    pretty_print('Macro q set to -target', 'Terraform')
  end,
  ['[Terraform] Remove terragrunt files'] = function()
    require('lazy').load { plugins = { 'vim-fugitive' } }
    local scan_dir = require 'plenary.scandir'
    local terraform_repo = vim.fn.FugitiveExecute({ 'rev-parse', '--show-toplevel' }).stdout
    scan_dir.scan_dir(terraform_repo, {
      add_dirs = false,
      respect_gitignore = false,
      search_pattern = '.*%.tf',
      on_insert = function(entry)
        local first_line = vim.fn.readfile(entry)[1]
        if first_line:match 'Generated by Terragrunt' then
          vim.notify('Deleting file: ' .. entry)
          vim.fn.delete(entry)
        end
      end,
    })
  end,
  ['[Terraform] leave "will be" on plan'] = function()
    vim.cmd [[
      v? will be ?d
      %s?\v^\s*#\s*(.*) will be (.*)?\1 \2?
    ]]
  end,
  ['Basic groovy format'] = function()
    vim.cmd.BasicGroovyFormat()
  end,
  ['Where am I?'] = function()
    vim.cmd.Whereami()
  end,
  ['Autocommand to reload the lua file nvim'] = function()
    if vim.api.nvim_get_option_value('filetype', { buf = 0 }) ~= 'lua' then
      ---@diagnostic disable-next-line: param-type-mismatch
      pretty_print('Filetype is not lua!', [[üñ•Ô∏è]], vim.log.levels.ERROR)
      return
    end

    local text = [[
-- Reload the file when it changes on disk
local group = vim.api.nvim_create_augroup("ReloadModule", {clear = true})
vim.api.nvim_create_autocmd("BufWritePost", {
	buffer = 0,
	group = group,
	callback = function()
		vim.cmd("luafile %")
		vim.notify("Module reloaded")
	end,
})

vim.keymap.set('n', 'bla', function()
  vim.notify('hello!')
end)
    ]]
    -- prepend those lines to the beggining of the file
    vim.api.nvim_buf_set_lines(0, 0, 0, false, vim.split(text, '\n'))
    vim.cmd.write()
    vim.cmd 'luafile %'
  end,
  ['Center Focus (zz)'] = function()
    vim.fn.feedkeys 'zz'
  end,
  ['Bottom Focus (zb)'] = function()
    vim.fn.feedkeys 'zb'
  end,
  ['Top Focus (zt)'] = function()
    vim.fn.feedkeys 'zt'
  end,
  ['Record Macro (q{letter})'] = function()
    vim.ui.input({ prompt = 'Macro letter: ' }, function(macro_letter)
      if not macro_letter then
        macro_letter = 'q'
      end
      vim.fn.feedkeys('q' .. macro_letter)
      pretty_print('Recording macro ' .. macro_letter .. ' (hit q when finished)', 'Macro')
      pretty_print('You can repeat this macro with @' .. macro_letter, 'Macro')
    end)
  end,
  ['Repeat Macro (@{letter} / Q)'] = function()
    vim.ui.input({ prompt = 'Macro letter: ' }, function(macro_letter)
      if not macro_letter then
        macro_letter = 'q'
      end
      vim.ui.input({ prompt = 'Enter how many times (leave blank for once): ' }, function(macro_times)
        if not macro_times then
          macro_times = ''
        end
        vim.fn.feedkeys(macro_times .. '@' .. macro_letter)
      end)
    end)
  end,
  ['Save current buffer as temp'] = function()
    local ft = vim.api.nvim_get_option_value('filetype', { buf = 0 })
    if ft == '' then
      vim.ui.select(vim.fn.getcompletion('', 'filetype'), { prompt = 'Filetype' }, function(selected)
        if not selected then
          pretty_print 'Canceled.'
          return
        end
        vim.cmd('set filetype=' .. selected)
        -- save with the filetype extension
        vim.cmd('write ' .. vim.fn.tempname() .. '.' .. selected)
        vim.cmd 'edit'
      end)
    else
      vim.cmd('write ' .. vim.fn.tempname() .. '.' .. ft)
      vim.cmd 'edit'
    end
  end,
  ['Find files (<C-p>)'] = function()
    vim.cmd 'FzfLua files'
  end,
  ['Find buffers (<C-b>)'] = function()
    vim.cmd 'FzfLua buffers'
  end,
  ['Open Nvim Tree File Browser (<C-o>)'] = function()
    local api = require 'nvim-tree.api'
    api.tree.toggle()
  end,
  ['Close all notifications (<leader>x)'] = function()
    require('notify').dismiss { pending = true, silent = true }
  end,
  ['Quit all (<leader>qq)'] = function()
    vim.cmd.qall()
  end,
  ['Paste from clipboard (cv)'] = function()
    vim.fn.feedkeys 'cv'
  end,
  ['Copy entire file to clipboard (Y)'] = function()
    vim.fn.feedkeys 'Y'
  end,
  ['Convert \\n to new lines (<leader><cr>)'] = function()
    vim.fn.feedkeys(T '<leader>' .. T '<cr>')
  end,
  ['Move line down (-)'] = function()
    vim.fn.feedkeys '-'
  end,
  ['Move line up (_)'] = function()
    vim.fn.feedkeys '_'
  end,
  ['Toggle words wrapping (<leader>ww)'] = function()
    vim.o.wrap = not vim.o.wrap
  end,
  ['Copy full file path to clipboard (<leader>cfa)'] = function()
    vim.fn.feedkeys(T '<leader>' .. 'cfa')
  end,
  ['Copy relative file path to clipboard (<leader>cfp)'] = function()
    vim.fn.feedkeys(T '<leader>' .. 'cfp')
  end,
  ['Copy directory path to clipboard (<leader>cfd)'] = function()
    vim.fn.feedkeys(T '<leader>' .. 'cfd')
  end,
  ['Copy file name to clipboard (<leader>cfn)'] = function()
    vim.fn.feedkeys(T '<leader>' .. 'cfn')
  end,
  ['Split long bash line (<leader>\\'] = function()
    vim.fn.feedkeys(T '<leader>' .. [[\]])
  end,
  ['[YAML] Yaml to Json (:Yaml2Json)'] = function()
    vim.cmd.Yaml2Json()
  end,
  ['[YAML] Add YAML Schema Modeline'] = function()
    require('user.additional-schemas').init()
  end,
  ['[JSON] Json to Yaml (:Json2Yaml)'] = function()
    vim.cmd.Json2Yaml()
  end,
  ['Change indent size (<leader>cii)'] = function()
    vim.fn.feedkeys(T '<leader>' .. 'cii')
  end,
  ['Convert tabs to spaces (<leader>ct<SPC>)'] = function()
    local original_expandtab = vim.opt_global.expandtab:get()
    vim.opt.expandtab = true
    vim.cmd.retab()
    vim.opt.expandtab = original_expandtab
  end,
  ['[Diff] unsaved with saved file (<leader>ds)'] = function()
    vim.fn.feedkeys(T '<leader>' .. 'ds')
  end,
}
