scriptencoding utf-8
" Moshe's plugins and plugin configuration. Complementary to my .vimrc file

" .    .         .              .
" |\  /|         |             / \               o
" | \/ | .-. .--.|--. .-.     /___\.    ._.--.   .
" |    |(   )`--.|  |(.-'    /     \\  /  |  |   |
" '    ' `-' `--''  `-`--'  '       ``'   '  `--' `-

" Plugins {{{
let s:vimplug_dir = '~/.vim/plugged'
call plug#begin(s:vimplug_dir)

<<<<<<< HEAD
Plug 'kyazdani42/nvim-tree.lua'
Plug 'rhysd/git-messenger.vim'
=======
Plug 'preservim/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-fugitive'
Plug 'mosheavni/vim-to-github'
Plug 'rhysd/conflict-marker.vim'
>>>>>>> origin/master

Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}  " We recommend updating the parsers on update

Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'

Plug 'mosheavni/vim-dirdiff'

Plug 'sheerun/vim-polyglot'
Plug 'neovim/nvim-lspconfig'
Plug 'hrsh7th/nvim-compe'
Plug 'iamcco/markdown-preview.nvim', { 'do': 'cd app & yarn install'  }
Plug 'vim-scripts/groovyindent-unix'
Plug 'chr4/nginx.vim'
Plug 'styled-components/vim-styled-components', { 'branch': 'main' }
Plug 'rayburgemeestre/phpfolding.vim', {'for': ['php']}
Plug 'towolf/vim-helm'
Plug 'andrewstuart/vim-kubernetes'

Plug 'mogelbrod/vim-jsonpath'
Plug 'chrisbra/vim-sh-indent'
Plug 'hashivim/vim-terraform'

Plug 'honza/vim-snippets'
Plug 'phenomenes/ansible-snippets'

<<<<<<< HEAD
Plug 'mg979/vim-visual-multi', {'branch': 'master'}
Plug 'yuttie/comfortable-motion.vim'
=======
Plug 'terryma/vim-smooth-scroll'
>>>>>>> origin/master

Plug 'christoomey/vim-system-copy'
Plug 'danro/rename.vim'
Plug 'voldikss/vim-floaterm'

Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-commentary'
Plug 'junegunn/vim-easy-align'
Plug 'AndrewRadev/switch.vim'
Plug 'justinmk/vim-sneak'

Plug 'simeji/winresizer'

Plug 'alvan/vim-closetag'
Plug 'kshenoy/vim-signature'

Plug 'editorconfig/editorconfig-vim'

Plug 'glepnir/galaxyline.nvim' , {'branch': 'main'}
Plug 'drewtempelmeyer/palenight.vim'
Plug 'joshdick/onedark.vim'
<<<<<<< HEAD
Plug 'rafamadriz/neon'
=======
Plug 'ghifarit53/tokyonight-vim'
Plug 'dracula/vim'
Plug 'jacoborus/tender.vim'

>>>>>>> origin/master
Plug 'machakann/vim-highlightedyank'
Plug 'mhinz/vim-startify'
Plug 'vim-scripts/CursorLineCurrentWindow'

" Custom text object
Plug 'kana/vim-textobj-user'
Plug 'mattn/vim-textobj-url'
Plug 'bps/vim-textobj-python'
Plug 'rhysd/vim-textobj-anyblock'
Plug 'kana/vim-textobj-entire'
Plug 'vimtaku/vim-textobj-keyvalue'

" Devicons is last so it can support all of the other plugins
Plug 'kyazdani42/nvim-web-devicons'
Plug 'akinsho/nvim-bufferline.lua'

call plug#end()

if !isdirectory(expand(s:vimplug_dir))
  finish
endif

" }}}

<<<<<<< HEAD
" Telescope {{{
nnoremap <c-p> <cmd>Telescope find_files find_command=rg,--ignore,--hidden,--files,-g,!.git/ prompt_prefix=üîç<cr>
nnoremap <c-b> <cmd>Telescope buffers<cr>
nnoremap <c-f> <cmd>Telescope live_grep<cr>
nnoremap <F4> <cmd>Telescope git_branches<cr>

lua << EOF
local actions = require('telescope.actions')
require('telescope').setup{
  defaults = {
    mappings = {
      i = {
        ["<esc>"] = actions.close
      },
    },
  }
}
EOF
=======
" Color settings {{{

" Random color {{{
function! RandomColorChooser() abort
  let l:liked_colors =  [
        \ 'OceanicNext',
        \ 'apprentice',
        \ 'deep-space',
        \ 'dracula',
        \ 'onedark',
        \ 'onehalfdark',
        \ 'purify',
        \ 'quantum',
        \ 'sonokai',
        \ 'two-firewatch'
        \ ]
  let l:random_color = l:liked_colors[localtime() % len(l:liked_colors)]
  exe 'colorscheme '. l:random_color
endfunction
" call RandomColorChooser()
" }}}

" let g:edge_style = 'neon'
" let g:palenight_terminal_italics=1
" colorscheme palenight
" colorscheme dracula
" colo edge

let g:tokyonight_style = 'night' " available: night, storm
let g:tokyonight_enable_italic = 1
colorscheme palenight

" }}}

" Fzf {{{
" nnoremap <c-p> :Files
nnoremap <silent> <expr> <c-p> (expand('%') =~ 'NERD_tree' ? "\<c-w>\<c-w>" : '').":Files\<cr>"
let $FZF_DEFAULT_COMMAND = "rg --files --hidden -g '!.git/' --color=never"
" let $FZF_DEFAULT_COMMAND = 'ag --hidden --ignore .git -l -g ""'
let $FZF_DEFAULT_OPTS    = '--bind ctrl-a:select-all'
" nnoremap <c-t> :Tags<cr>
nnoremap <c-b> :Buffers<cr>
nnoremap <F4> :Gb<cr>
nnoremap <c-y> :History<cr>
>>>>>>> origin/master

" }}}

" Ultisnip {{{
let g:UltiSnipsExpandTrigger='<c-s>'
" }}}

" Vim auto pairs {{{
let g:AutoPairsShortcutJump = ''
let g:AutoPairsShortcutToggle = ''
" }}}

" Vim json path {{{
let g:jsonpath_register = '*'
" }}}

" WinResizer {{{
let g:winresizer_start_key = '<C-E>'
" }}}

" Floaterm {{{
let g:floaterm_keymap_toggle = '<F6>'
let g:floaterm_keymap_new    = '<F7>'
let g:floaterm_keymap_next   = '<F8>'
let g:floaterm_width = 0.7
let g:floaterm_height = 0.9

" }}}

" DirDiff {{{
" let g:DirDiffEnableMappings = 1
" let g:DirDiffNextKeyMap = ']q'
" let g:DirDiffPrevKeyMap = '[q'

" }}}

" Switch vim {{{
" let g:switch_mapping = '-'
" The map switch is between underscores to camelCase: moshe_king -> mosheKing
" -> moshe_king
let g:switch_custom_definitions = [
      \   ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'],
      \   ['==', '!='],
      \   {
      \     '\<[a-z0-9]\+_\k\+\>': {
      \       '_\(.\)': '\U\1'
      \     },
      \     '\<[a-z0-9]\+[A-Z]\k\+\>': {
      \       '\([A-Z]\)': '_\l\1'
      \     },
      \   }
      \ ]
" }}}

" Vim session {{{
let g:session_autoload = 'no'
let g:session_autosave = 'no'
" }}}

" Smooth scroll {{{
let g:comfortable_motion_no_default_key_mappings = 1
let g:comfortable_motion_impulse_multiplier = 1  " Feel free to increase/decrease this value.
nnoremap <silent> <C-d> :call comfortable_motion#flick(g:comfortable_motion_impulse_multiplier * winheight(0) * 2)<CR>
nnoremap <silent> <C-u> :call comfortable_motion#flick(g:comfortable_motion_impulse_multiplier * winheight(0) * -2)<CR>
" }}}

" Vim ansible {{{
let g:ansible_goto_role_paths = '.;,roles;'

function! FindAnsibleRoleUnderCursor()
  let l:role_paths = get(g:, 'ansible_goto_role_paths', './roles')
  let l:tasks_main = expand('<cfile>') . '/tasks/main.yml'
  let l:found_role_path = findfile(l:tasks_main, l:role_paths)
  if l:found_role_path == ''
    echo l:tasks_main . ' not found'
  else
    execute 'edit ' . fnameescape(l:found_role_path)
  endif
endfunction
augroup AnsibleFind
  autocmd!

  au BufRead,BufNewFile */ansible/*.yml nnoremap <silent> <leader>gr :call FindAnsibleRoleUnderCursor()<CR>
  au BufRead,BufNewFile */ansible/*.yml vnoremap <silent> <leader>gr :call FindAnsibleRoleUnderCursor()<CR>
augroup END
" }}}

" Editor config {{{
let g:EditorConfig_exclude_patterns = ['fugitive://.*']
" }}}

" Vim terraform {{{
let g:terraform_fmt_on_save=1
" }}}

" Vim easy align {{{
nmap ga <Plug>(EasyAlign)
" }}}

" Vim close tag {{{
let g:closetag_filenames = '*.html,*.xhtml,*.phtml,*.erb,*.jsx,*.tsx,*.js'
let g:closetag_filetypes = 'html,xhtml,phtml,javascript,javascriptreact'
" }}}

<<<<<<< HEAD
" Vim visual multi {{{
let g:VM_maps = {}
" let g:VM_maps["Select Cursor Down"] = '<c-j>'      " start selecting down
" let g:VM_maps["Select Cursor Up"]   = '<c-k>'        " start selecting up
" }}}

" Color settings {{{

" Vim rainbow {{{
let g:rainbow_active = 1 "set to 0 if you want to enable it later via :RainbowToggle
" }}}

" Random color {{{
function! RandomColorChooser() abort
  let l:liked_colors =  [
        \ 'OceanicNext',
        \ 'apprentice',
        \ 'deep-space',
        \ 'dracula',
        \ 'onedark',
        \ 'onehalfdark',
        \ 'purify',
        \ 'quantum',
        \ 'sonokai',
        \ 'two-firewatch'
        \ ]
  let l:random_color = l:liked_colors[localtime() % len(l:liked_colors)]
  exe 'colorscheme '. l:random_color
endfunction
" call RandomColorChooser()
let g:edge_style = 'neon'
let g:palenight_terminal_italics=1
" colorscheme palenight
colorscheme neon
hi clear CursorColumn
hi link CursorColumn CursorLine
" colo edge

" }}}

" }}}

" Conflict marker {{{
let g:conflict_marker_highlight_group = 'VisualNOS'
highlight ConflictMarkerBegin guibg=#2f7366
highlight ConflictMarkerOurs guibg=#2e5049
highlight ConflictMarkerTheirs guibg=#344f69
highlight ConflictMarkerEnd guibg=#2f628e
highlight ConflictMarkerCommonAncestorsHunk guibg=#754a81

" }}}

=======
>>>>>>> origin/master
" Startify {{{

let g:startify_custom_header = [
      \'   üòé               üéÉ              üòé',
      \'    _   _         __     ___',
      \'   | \ | | ___  __\ \   / (_)_ __ ___',
      \'   |  \| |/ _ \/ _ \ \ / /| | ''_ ` _ \',
      \'   | |\  |  __/ (_) \ V / | | | | | | |',
      \'   |_| \_|\___|\___/ \_/  |_|_| |_| |_|',
      \'', '   üöÄ               ‚ú®              üöÄ'
      \]

" }}}

" DevIcons {{{
let g:WebDevIconsOS = 'Darwin'
let g:DevIconsEnableFoldersOpenClose = 1
let g:DevIconsEnableFolderExtensionPatternMatching = 1
" }}}

" GitGutter {{{
let g:gitgutter_map_keys = 1
let g:gitgutter_highlight_lines = 0
let g:gitgutter_highlight_linenrs = 1
nnoremap <leader>gc :GitGutterLineHighlightsToggle<cr>
nnoremap <leader>cag :GitGutterFold<cr>
nmap ]c <Plug>(GitGutterNextHunk)
nmap [c <Plug>(GitGutterPrevHunk)
function! GitStatus()
  let [a,m,r] = GitGutterGetHunkSummary()
  return printf('+%d ~%d -%d', a, m, r)
endfunction
<<<<<<< HEAD
set statusline+=%{GitStatus()}
=======
>>>>>>> origin/master
highlight clear SignColumn
highlight GitGutterAdd    guifg=#009900 ctermfg=2
highlight GitGutterChange guifg=#ffff61 ctermfg=3
highlight GitGutterDelete guifg=#ff2222 ctermfg=1
highlight! link SignColumn LineNr
<<<<<<< HEAD

" }}}

" nvim bufferline tabline {{{
lua require("bufferline").setup{}
" }}}

" nvim-lsp {{{
luafile ~/.vim/lsp_config.lua
=======
" }}}

" Vim lightline {{{
let g:lightline = {
      \ 'colorscheme': 'tokyonight',
      \ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      \ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" },
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'readonly', 'filename', 'modified', 'cocstatus' ],
      \             [ 'gitbranch', 'unpushed_unpulled', 'gitstatus' ]
      \ ],
      \   'right': [ [ 'virtualenv', 'filetype', 'line', 'column' ] ]
      \ },
      \ 'inactive': {
      \   'left': [ [ 'readonly', 'filename', 'modified' ] ],
		  \   'right': [ [ 'filetypelogo', 'gitbranch' ] ]
      \ },
      \ 'tabline': {
      \   'left': [ ['buffers'] ],
      \   'right': [ ['close'] ]
      \ },
      \ 'component_function': {
      \   'gitbranch': 'FugitiveHead',
      \   'gitstatus': 'GitStatus',
      \   'unpushed_unpulled': 'Unpushed_Unpulled',
      \   'filetype': 'LightlineDevIconsFiletype',
      \   'fileformat': 'LightlineDevIconsFileformat',
      \   'filetypelogo': 'WebDevIconsGetFileTypeSymbol',
      \   'cocstatus': 'coc#status',
      \   'virtualenv': 'CheckVirtualEnv',
      \ },
      \ 'component_expand': {
      \   'buffers': 'lightline#bufferline#buffers'
      \ },
      \ 'component_type': {
      \   'buffers': 'tabsel'
      \ },
      \ 'component_raw': {'buffers': 1}
      \ }

function! LightlineDevIconsFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ?  WebDevIconsGetFileTypeSymbol() . ' ' .&filetype : 'no ft') : WebDevIconsGetFileTypeSymbol()
endfunction

function! LightlineDevIconsFileformat()
  return winwidth(0) > 70 ? (WebDevIconsGetFileFormatSymbol() . ' ' . &fileformat) : WebDevIconsGetFileFormatSymbol()
endfunction

function CheckVirtualEnv() abort
  let virtualenv = $VIRTUAL_ENV
  if empty(virtualenv)
    return ''
  endif
  return printf('(%s)',split(virtualenv, '/')[-1])
endfunction

function! s:set_lightline_colorscheme(name) abort
  let g:lightline.colorscheme = a:name
  call lightline#init()
  call lightline#colorscheme()
  call lightline#update()
endfunction

function! s:lightline_colorschemes(...) abort
  return join(map(
        \ globpath(&rtp,'autoload/lightline/colorscheme/*.vim',1,1),
        \ "fnamemodify(v:val,':t:r')"),
        \ "\n")
endfunction

command! -nargs=1 -complete=custom,s:lightline_colorschemes LightlineColorscheme
          \ call s:set_lightline_colorscheme(<q-args>)

let g:lightline#bufferline#show_number=1
let g:lightline#bufferline#enable_devicons=1
let g:lightline#bufferline#filename_modifier = ':t'
let g:lightline#bufferline#margin_left=1
let g:lightline#bufferline#margin_right=1
let g:lightline#bufferline#clickable=1
" }}}

" Coc {{{

" Plugins backup {{{
let g:coc_global_extensions = [
      \    'coc-cfn-lint',
      \    'coc-css',
      \    'coc-diagnostic',
      \    'coc-dictionary',
      \    'coc-docker',
      \    'coc-lua',
      \    'coc-emmet',
      \    'coc-emoji',
      \    'coc-eslint',
      \    'coc-gitignore',
      \    'coc-groovy',
      \    'coc-highlight',
      \    'coc-html',
      \    'coc-html-css-support',
      \    'coc-json',
      \    'coc-markdownlint',
      \    'coc-marketplace',
      \    'coc-neosnippet',
      \    'coc-pairs',
      \    'coc-prettier',
      \    'coc-pyright',
      \    'coc-react-refactor',
      \    'coc-scssmodules',
      \    'coc-sh',
      \    'coc-snippets',
      \    'coc-styled-components',
      \    'coc-swagger',
      \    'coc-syntax',
      \    'coc-tabnine',
      \    'coc-tag',
      \    'coc-tsserver',
      \    'coc-vimlsp',
      \    'coc-xml',
      \    'coc-yaml'
      \]
" }}}

" Install all plugins {{{
>>>>>>> origin/master

sign define LspDiagnosticsSignError text=üî¥
sign define LspDiagnosticsSignWarning text=üü†
sign define LspDiagnosticsSignInformation text=üîµ
sign define LspDiagnosticsSignHint text=üü¢

nnoremap <silent> gd         <cmd>lua vim.lsp.buf.definition()<CR>
nnoremap <silent> gi         <cmd>lua vim.lsp.buf.implementation()<CR>
nnoremap <silent> gr         <cmd>lua vim.lsp.buf.references()<CR>
nnoremap <silent> gD         <cmd>lua vim.lsp.buf.declaration()<CR>
nnoremap <silent> ge         <cmd>lua vim.lsp.diagnostic.set_loclist()<CR>
nnoremap <silent> K          <cmd>lua vim.lsp.buf.hover()<CR>
nnoremap <silent> <leader>p  <cmd>lua vim.lsp.buf.formatting()<CR>
nnoremap <silent> <leader>rn <cmd>lua vim.lsp.buf.rename()<CR>
nnoremap <silent> <leader>a  <cmd>lua vim.lsp.buf.code_action()<CR>
xmap     <silent> <leader>a  <cmd>lua vim.lsp.buf.range_code_action()<CR>

<<<<<<< HEAD
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" Set completeopt to have a better completion experience
set completeopt=menuone,noinsert,noselect

inoremap <silent><expr> <C-Space> compe#complete()
inoremap <silent><expr> <CR>      compe#confirm('<CR>')
inoremap <silent><expr> <C-e>     compe#close('<C-e>')
inoremap <silent><expr> <C-f>     compe#scroll({ 'delta': +4 })
inoremap <silent><expr> <C-d>     compe#scroll({ 'delta': -4 })

" }}}
=======
" }}}

" use <tab> for trigger completion and navigate to the next complete item {{{
function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"
" }}}

" Use <c-space> to trigger completion.
if has('nvim')
  inoremap <silent><expr> <c-space> coc#refresh()
else
  inoremap <silent><expr> <c-@> coc#refresh()
endif

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
" position. Coc only does snippet and additional edit on confirm.
" <cr> could be remapped by other vim plugin, try `:verbose imap <CR>`.
if exists('*complete_info')
  inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
else
  inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
endif

" Use `[g` and `]g` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" GoTo code navigation.
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
" nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Project replace word
nnoremap <leader>prn :CocSearch <C-R>=expand("<cword>")<CR><CR>
vnoremap <leader>prn "iy:<c-u>CocSearch <C-R>i<CR><CR>

hi CocHighlightText ctermbg=241 guibg=#665c54
hi! link CocHoverRange CocHighlightText

" Symbol renaming.
nmap <leader>rn <Plug>(coc-rename)

augroup format_coc_group
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
  " Highlight the symbol and its references when holding the cursor.
  autocmd CursorHold * silent call CocActionAsync('highlight')

  autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()
augroup end

" Use K to show documentation in preview window.
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . ' ' . expand('<cword>')
  endif
endfunction

" Use CTRL-S for selections ranges.
" Requires 'textDocument/selectionRange' support of LS, ex: coc-tsserver
nmap <silent> <C-s> <Plug>(coc-range-select)
xmap <silent> <C-s> <Plug>(coc-range-select)

" Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')
nmap <silent><expr> <leader>p CocHasProvider('format') ? "\<Plug>(coc-format)" : ":call FormatEqual()\<cr>"

" Add `:Fold` command to fold current buffer.
command! -nargs=? Fold :call     CocAction('fold', <f-args>)

" Add `:OR` command for organize imports of the current buffer.
command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

" Add (Neo)Vim's native statusline support.
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline.
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

" Mappings for CoCList
" Show commands.
nnoremap <silent><nowait> <leader>cc  :<C-u>CocList commands<cr>
nnoremap <silent><nowait> <leader>a   <Plug>(coc-codeaction)
" Applying codeAction to the selected region.
" Example: `<leader>aap` for current paragraph
xmap <leader>a  <Plug>(coc-codeaction-selected)
nmap <leader>a  <Plug>(coc-codeaction-selected)
" Search workspace symbols.
" nnoremap <silent><nowait> <space>s  :<C-u>CocList -I symbols<cr>
" Do default action for next item.
nnoremap <silent><nowait> <space>j  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent><nowait> <space>k  :<C-u>CocPrev<CR>
" }}}

" Nerd Tree {{{

let g:NERDTreeChDirMode = 2
let g:NERDTreeHijackNetrw = 1
let g:NERDTreeShowHidden=1
let g:NERDTreeHighlightCursorline = 1
let g:NERDTreeFileExtensionHighlightFullName = 1

" " ### nerdtree-git-plugin ###
let g:NERDTreeGitStatusUseNerdFonts = 1
" let g:NERDTreeGitStatusConcealBrackets = 1

let g:NERDTreeGitStatusIndicatorMapCustom = {
    \ 'Modified'  : '‚úπ',
    \ 'Staged'    : '‚úö',
    \ 'Untracked' : '‚ú≠',
    \ 'Unmerged'  : '‚ïê',
    \ 'Dirty'     : '‚úó',
    \ 'Renamed'   : '‚ûú',
    \ 'Clean'     : '‚úîÔ∏é',
    \ 'Ignored'   : '‚òí',
    \ 'Deleted'   : '‚úñ',
    \ 'Unknown'   : '?'
    \ }
" " Set icon for Jenkinsfile
" let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols = {}
" let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols['Jenkinsfile'] = 'Óòï'
" let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols['\..*ignore.*'] = 'Óòï'

" let g:NERDTreePatternMatchHighlightColor = {}
" let g:NERDTreePatternMatchHighlightColor['\..*ignore.*'] = 'EE6E73'
" let g:NERDTreePatternMatchHighlightColor['Jenkinsfile'] = '62a2bf'

" If more than one window and previous buffer was NERDTree, go back to it.
" autocmd BufEnter * if bufname('#') =~# "^NERD_tree_" && winnr("$") > 1 | b# | endif


" Check if NERDTree is open or active
function! IsNERDTreeOpen()
  return exists('t:NERDTreeBufName') && (bufwinnr(t:NERDTreeBufName) != -1)
endfunction
>>>>>>> origin/master

" nvim Tree {{{

nnoremap <silent> <C-o> :NvimTreeToggle<CR>
nnoremap <leader>v :NvimTreeFindFile<CR>

let g:nvim_tree_icons = {
    \ 'default': 'Óòí',
    \ 'symlink': 'ÔíÅ',
    \ 'git': {
    \   'unstaged': '‚úó',
    \   'staged': '‚úì',
    \   'unmerged': 'Óúß',
    \   'renamed': '‚ûú',
    \   'untracked': '‚òÖ',
    \   'deleted': 'Ôëò',
    \   'ignored': '‚óå'
  \   }
\ }

" }}}

" Fugitive {{{

" Remove all conflict markers command
"Delete all Git conflict markers
"Creates the command :GremoveConflictMarkers
function! RemoveConflictMarkers() range
  echom a:firstline.'-'.a:lastline
  execute a:firstline.','.a:lastline . ' g/^<\{7}\|^|\{7}\|^=\{7}\|^>\{7}/d'
endfunction
"-range=% default is whole file
command! -range=% GremoveConflictMarkers <line1>,<line2>call RemoveConflictMarkers()


" Better branch choosing using :Gbranch
function! s:changebranch(...)
  let name = a:1
  if name ==? ''
    call inputsave()
    let name = input('Enter branch name: ')
    call inputrestore()
  endif
  execute 'Git checkout ' . name
  if name ==# 'master'
    Git fetch
  endif
endfunction

function! s:call_fzf_changebranch()
  call fzf#run({
        \ 'source': 'git for-each-ref --sort=-committerdate --format="%(refname:short)" | grep -n . | sed "s?origin/??g" | sort -t: -k2 -u | sort -n | cut -d: -f2',
        \ 'sink': function('s:changebranch')
        \ })

endfunction

command! -bang Gbranch call s:call_fzf_changebranch()
command! -bang Gb      call s:call_fzf_changebranch()
command! -nargs=? Gco call s:changebranch("<args>")

" Git push + pull + autocmd {{{

" Push
function! s:MosheGitPush() abort
  echo 'Pushing to ' . FugitiveHead() . '...'
  exe 'Git push -u origin ' . FugitiveHead()
  let l:exit_status = get(FugitiveResult(), 'exit_status', 1)
  if l:exit_status != 0
    echo 'Failed pushing üòí'
  else
    echo 'Pushed! ü§©'
  endif
endfunction
command! Gp call <sid>MosheGitPush()
nmap <silent> <leader>gp :Gp<cr>

" Pull
function! s:MosheGitPull() abort
  echo 'Pulling...'
  Git pull --quiet
  let l:exit_status = get(FugitiveResult(), 'exit_status', 1)
  if l:exit_status != 0
    echo 'Failed pulling üòí'
  else
    echo 'Pulled! üòé'
  endif
endfunction
command! -bang Gl call <sid>MosheGitPull()
nmap <silent> <leader>gl :Gl<cr>

" Autocmd
function! s:ftplugin_fugitive() abort
  nnoremap <buffer> <silent> cc :Git commit --quiet<CR>
  nnoremap <buffer> <silent> gl :Gl<CR>
  nnoremap <buffer> <silent> gp :Gp<CR>
endfunction
augroup moshe_fugitive
  autocmd!
  autocmd FileType fugitive call s:ftplugin_fugitive()
augroup END

" }}}

" Git merge origin master
command! -bang Gmom G merge origin/master

" Create a new branch
function! Gcb(...)
  let name = a:1
  if name ==? ''
    call inputsave()
    let name = input('Enter branch name: ')
    call inputrestore()
  endif
  echom ''
  execute 'Git checkout -b ' . name
endfunction
command! -nargs=? Gcb call Gcb("<args>")

function! ToggleGStatus()
  if buflisted(bufname('.git/index'))
    bd .git/index
  else
    Git
    " 20wincmd_
  endif
endfunction
command! ToggleGStatus :call ToggleGStatus()
nnoremap <silent> <leader>gg :ToggleGStatus<cr>

" Gdiffrev {{{
nmap <leader>dh :DiffHistory<Space>
command! -nargs=? DiffHistory call s:view_git_history('<args>')
command! DiffFile call s:view_git_history('current_file')
nmap <silent> <leader>gh :DiffFile<cr>

function! s:view_git_history(...) abort
  let branch_name = a:1
  if branch_name ==# 'current_file'
    0Gclog
  elseif branch_name !=? ''
    execute 'Git difftool --name-only ' . branch_name . '...@'
  else
    Git difftool --name-only ! !^@
  endif
  call s:diff_current_quickfix_entry()
  " Bind <CR> for current quickfix window to properly set up diff split layout after selecting an item
  " There's probably a better way to map this without changing the window
  copen
  nnoremap <buffer> <CR> <CR><BAR>:call <sid>diff_current_quickfix_entry()<CR>
  wincmd p
endfunction

function s:diff_current_quickfix_entry() abort
  " Cleanup windows
  for window in getwininfo()
    if window.winnr !=? winnr() && bufname(window.bufnr) =~? '^fugitive:'
      exe 'bdelete' window.bufnr
    endif
  endfor
  cc
  call s:add_mappings()
  let qf = getqflist({'context': 0, 'idx': 0})
  if get(qf, 'idx') && type(get(qf, 'context')) == type({}) && type(get(qf.context, 'items')) == type([])
    let diff = get(qf.context.items[qf.idx - 1], 'diff', [])
    for i in reverse(range(len(diff)))
      exe (i ? 'leftabove' : 'rightbelow') 'vert diffsplit' fnameescape(diff[i].filename)
      call s:add_mappings()
    endfor
  endif
endfunction

function! s:add_mappings() abort
  nnoremap <buffer>]q :cnext <BAR> :call <sid>diff_current_quickfix_entry()<CR>
  nnoremap <buffer>[q :cprevious <BAR> :call <sid>diff_current_quickfix_entry()<CR>
  " Reset quickfix height. Sometimes it messes up after selecting another item
  11copen
  wincmd p
endfunction
" }}}

function Unpushed_Unpulled() abort
  " Don't operate if not on git directory
  if empty(FugitiveGitDir())
    return '‚Üë- ‚Üì-'
  endif
  let last_run = get(g:, 'unpushed_unpulled_last_run', 0)
  if last_run != 0 && last_run + 10 > strftime('%s')
    " Return already existing status
    return get(g:, 'unpushed_unpulled_last_status', 0)
  endif

  let unpushed_unpulled_line_string = '# branch.ab '
  let status_output = systemlist(FugitivePrepare([ 'status', '--porcelain=v2', '--branch' ]))
  let unpushed_unpulled_index = match(status_output, unpushed_unpulled_line_string)
  if unpushed_unpulled_index ==# -1
    return '‚Üë- ‚Üì-'
  endif
  let g:unpushed_unpulled_last_run = strftime('%s')
  let g:unpushed_unpulled_last_status = substitute(
          \ substitute(
            \ substitute(status_output[unpushed_unpulled_index], unpushed_unpulled_line_string, '', ''),
            \ '+', '‚Üë', ''
          \ ),
          \ '-', '‚Üì', ''
        \ )
  return g:unpushed_unpulled_last_status
endfunction

" }}}

<<<<<<< HEAD
" Treesitter {{{
lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "maintained", -- one of "all", "maintained" (parsers with maintainers), or a list of languages
  ignore_install = { "javascript" }, -- List of parsers to ignore installing
  highlight = {
    enable = true,              -- false will disable the whole extension
  },
indent = {
    enable = true
  }
}
EOF

set foldmethod=expr
set foldexpr=nvim_treesitter#foldexpr()
" }}}
=======
" Conflict marker {{{
let g:conflict_marker_highlight_group = 'VisualNOS'
highlight ConflictMarkerBegin guibg=#2f7366
highlight ConflictMarkerOurs guibg=#2e5049
highlight ConflictMarkerTheirs guibg=#344f69
highlight ConflictMarkerEnd guibg=#2f628e
highlight ConflictMarkerCommonAncestorsHunk guibg=#754a81

" }}}

" Load LUA
lua require('moshelua')
>>>>>>> origin/master
